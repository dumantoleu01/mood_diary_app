// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'mood_diary_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$MoodDiaryEvent {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MoodDiaryEvent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent()';
}


}

/// @nodoc
class $MoodDiaryEventCopyWith<$Res>  {
$MoodDiaryEventCopyWith(MoodDiaryEvent _, $Res Function(MoodDiaryEvent) __);
}


/// Adds pattern-matching-related methods to [MoodDiaryEvent].
extension MoodDiaryEventPatterns on MoodDiaryEvent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _LoadEntries value)?  loadEntries,TResult Function( _SelectMood value)?  selectMood,TResult Function( _ToggleSubEmotion value)?  toggleSubEmotion,TResult Function( _UpdateStressLevel value)?  updateStressLevel,TResult Function( _UpdateSelfEsteem value)?  updateSelfEsteem,TResult Function( _UpdateNote value)?  updateNote,TResult Function( _UpdateDateTime value)?  updateDateTime,TResult Function( _SaveEntry value)?  saveEntry,TResult Function( _ResetForm value)?  resetForm,TResult Function( _SwitchTab value)?  switchTab,TResult Function( _DeleteEntry value)?  deleteEntry,TResult Function( _StartEditEntry value)?  startEditEntry,TResult Function( _UpdateEntry value)?  updateEntry,TResult Function( _CancelEdit value)?  cancelEdit,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _LoadEntries() when loadEntries != null:
return loadEntries(_that);case _SelectMood() when selectMood != null:
return selectMood(_that);case _ToggleSubEmotion() when toggleSubEmotion != null:
return toggleSubEmotion(_that);case _UpdateStressLevel() when updateStressLevel != null:
return updateStressLevel(_that);case _UpdateSelfEsteem() when updateSelfEsteem != null:
return updateSelfEsteem(_that);case _UpdateNote() when updateNote != null:
return updateNote(_that);case _UpdateDateTime() when updateDateTime != null:
return updateDateTime(_that);case _SaveEntry() when saveEntry != null:
return saveEntry(_that);case _ResetForm() when resetForm != null:
return resetForm(_that);case _SwitchTab() when switchTab != null:
return switchTab(_that);case _DeleteEntry() when deleteEntry != null:
return deleteEntry(_that);case _StartEditEntry() when startEditEntry != null:
return startEditEntry(_that);case _UpdateEntry() when updateEntry != null:
return updateEntry(_that);case _CancelEdit() when cancelEdit != null:
return cancelEdit(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _LoadEntries value)  loadEntries,required TResult Function( _SelectMood value)  selectMood,required TResult Function( _ToggleSubEmotion value)  toggleSubEmotion,required TResult Function( _UpdateStressLevel value)  updateStressLevel,required TResult Function( _UpdateSelfEsteem value)  updateSelfEsteem,required TResult Function( _UpdateNote value)  updateNote,required TResult Function( _UpdateDateTime value)  updateDateTime,required TResult Function( _SaveEntry value)  saveEntry,required TResult Function( _ResetForm value)  resetForm,required TResult Function( _SwitchTab value)  switchTab,required TResult Function( _DeleteEntry value)  deleteEntry,required TResult Function( _StartEditEntry value)  startEditEntry,required TResult Function( _UpdateEntry value)  updateEntry,required TResult Function( _CancelEdit value)  cancelEdit,}){
final _that = this;
switch (_that) {
case _LoadEntries():
return loadEntries(_that);case _SelectMood():
return selectMood(_that);case _ToggleSubEmotion():
return toggleSubEmotion(_that);case _UpdateStressLevel():
return updateStressLevel(_that);case _UpdateSelfEsteem():
return updateSelfEsteem(_that);case _UpdateNote():
return updateNote(_that);case _UpdateDateTime():
return updateDateTime(_that);case _SaveEntry():
return saveEntry(_that);case _ResetForm():
return resetForm(_that);case _SwitchTab():
return switchTab(_that);case _DeleteEntry():
return deleteEntry(_that);case _StartEditEntry():
return startEditEntry(_that);case _UpdateEntry():
return updateEntry(_that);case _CancelEdit():
return cancelEdit(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _LoadEntries value)?  loadEntries,TResult? Function( _SelectMood value)?  selectMood,TResult? Function( _ToggleSubEmotion value)?  toggleSubEmotion,TResult? Function( _UpdateStressLevel value)?  updateStressLevel,TResult? Function( _UpdateSelfEsteem value)?  updateSelfEsteem,TResult? Function( _UpdateNote value)?  updateNote,TResult? Function( _UpdateDateTime value)?  updateDateTime,TResult? Function( _SaveEntry value)?  saveEntry,TResult? Function( _ResetForm value)?  resetForm,TResult? Function( _SwitchTab value)?  switchTab,TResult? Function( _DeleteEntry value)?  deleteEntry,TResult? Function( _StartEditEntry value)?  startEditEntry,TResult? Function( _UpdateEntry value)?  updateEntry,TResult? Function( _CancelEdit value)?  cancelEdit,}){
final _that = this;
switch (_that) {
case _LoadEntries() when loadEntries != null:
return loadEntries(_that);case _SelectMood() when selectMood != null:
return selectMood(_that);case _ToggleSubEmotion() when toggleSubEmotion != null:
return toggleSubEmotion(_that);case _UpdateStressLevel() when updateStressLevel != null:
return updateStressLevel(_that);case _UpdateSelfEsteem() when updateSelfEsteem != null:
return updateSelfEsteem(_that);case _UpdateNote() when updateNote != null:
return updateNote(_that);case _UpdateDateTime() when updateDateTime != null:
return updateDateTime(_that);case _SaveEntry() when saveEntry != null:
return saveEntry(_that);case _ResetForm() when resetForm != null:
return resetForm(_that);case _SwitchTab() when switchTab != null:
return switchTab(_that);case _DeleteEntry() when deleteEntry != null:
return deleteEntry(_that);case _StartEditEntry() when startEditEntry != null:
return startEditEntry(_that);case _UpdateEntry() when updateEntry != null:
return updateEntry(_that);case _CancelEdit() when cancelEdit != null:
return cancelEdit(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  loadEntries,TResult Function( MoodType moodType)?  selectMood,TResult Function( String emotion)?  toggleSubEmotion,TResult Function( int level)?  updateStressLevel,TResult Function( int level)?  updateSelfEsteem,TResult Function( String note)?  updateNote,TResult Function( DateTime dateTime)?  updateDateTime,TResult Function()?  saveEntry,TResult Function()?  resetForm,TResult Function( int tabIndex)?  switchTab,TResult Function( String id)?  deleteEntry,TResult Function( MoodEntry entry)?  startEditEntry,TResult Function()?  updateEntry,TResult Function()?  cancelEdit,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _LoadEntries() when loadEntries != null:
return loadEntries();case _SelectMood() when selectMood != null:
return selectMood(_that.moodType);case _ToggleSubEmotion() when toggleSubEmotion != null:
return toggleSubEmotion(_that.emotion);case _UpdateStressLevel() when updateStressLevel != null:
return updateStressLevel(_that.level);case _UpdateSelfEsteem() when updateSelfEsteem != null:
return updateSelfEsteem(_that.level);case _UpdateNote() when updateNote != null:
return updateNote(_that.note);case _UpdateDateTime() when updateDateTime != null:
return updateDateTime(_that.dateTime);case _SaveEntry() when saveEntry != null:
return saveEntry();case _ResetForm() when resetForm != null:
return resetForm();case _SwitchTab() when switchTab != null:
return switchTab(_that.tabIndex);case _DeleteEntry() when deleteEntry != null:
return deleteEntry(_that.id);case _StartEditEntry() when startEditEntry != null:
return startEditEntry(_that.entry);case _UpdateEntry() when updateEntry != null:
return updateEntry();case _CancelEdit() when cancelEdit != null:
return cancelEdit();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  loadEntries,required TResult Function( MoodType moodType)  selectMood,required TResult Function( String emotion)  toggleSubEmotion,required TResult Function( int level)  updateStressLevel,required TResult Function( int level)  updateSelfEsteem,required TResult Function( String note)  updateNote,required TResult Function( DateTime dateTime)  updateDateTime,required TResult Function()  saveEntry,required TResult Function()  resetForm,required TResult Function( int tabIndex)  switchTab,required TResult Function( String id)  deleteEntry,required TResult Function( MoodEntry entry)  startEditEntry,required TResult Function()  updateEntry,required TResult Function()  cancelEdit,}) {final _that = this;
switch (_that) {
case _LoadEntries():
return loadEntries();case _SelectMood():
return selectMood(_that.moodType);case _ToggleSubEmotion():
return toggleSubEmotion(_that.emotion);case _UpdateStressLevel():
return updateStressLevel(_that.level);case _UpdateSelfEsteem():
return updateSelfEsteem(_that.level);case _UpdateNote():
return updateNote(_that.note);case _UpdateDateTime():
return updateDateTime(_that.dateTime);case _SaveEntry():
return saveEntry();case _ResetForm():
return resetForm();case _SwitchTab():
return switchTab(_that.tabIndex);case _DeleteEntry():
return deleteEntry(_that.id);case _StartEditEntry():
return startEditEntry(_that.entry);case _UpdateEntry():
return updateEntry();case _CancelEdit():
return cancelEdit();case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  loadEntries,TResult? Function( MoodType moodType)?  selectMood,TResult? Function( String emotion)?  toggleSubEmotion,TResult? Function( int level)?  updateStressLevel,TResult? Function( int level)?  updateSelfEsteem,TResult? Function( String note)?  updateNote,TResult? Function( DateTime dateTime)?  updateDateTime,TResult? Function()?  saveEntry,TResult? Function()?  resetForm,TResult? Function( int tabIndex)?  switchTab,TResult? Function( String id)?  deleteEntry,TResult? Function( MoodEntry entry)?  startEditEntry,TResult? Function()?  updateEntry,TResult? Function()?  cancelEdit,}) {final _that = this;
switch (_that) {
case _LoadEntries() when loadEntries != null:
return loadEntries();case _SelectMood() when selectMood != null:
return selectMood(_that.moodType);case _ToggleSubEmotion() when toggleSubEmotion != null:
return toggleSubEmotion(_that.emotion);case _UpdateStressLevel() when updateStressLevel != null:
return updateStressLevel(_that.level);case _UpdateSelfEsteem() when updateSelfEsteem != null:
return updateSelfEsteem(_that.level);case _UpdateNote() when updateNote != null:
return updateNote(_that.note);case _UpdateDateTime() when updateDateTime != null:
return updateDateTime(_that.dateTime);case _SaveEntry() when saveEntry != null:
return saveEntry();case _ResetForm() when resetForm != null:
return resetForm();case _SwitchTab() when switchTab != null:
return switchTab(_that.tabIndex);case _DeleteEntry() when deleteEntry != null:
return deleteEntry(_that.id);case _StartEditEntry() when startEditEntry != null:
return startEditEntry(_that.entry);case _UpdateEntry() when updateEntry != null:
return updateEntry();case _CancelEdit() when cancelEdit != null:
return cancelEdit();case _:
  return null;

}
}

}

/// @nodoc


class _LoadEntries implements MoodDiaryEvent {
  const _LoadEntries();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LoadEntries);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent.loadEntries()';
}


}




/// @nodoc


class _SelectMood implements MoodDiaryEvent {
  const _SelectMood(this.moodType);
  

 final  MoodType moodType;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectMoodCopyWith<_SelectMood> get copyWith => __$SelectMoodCopyWithImpl<_SelectMood>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectMood&&(identical(other.moodType, moodType) || other.moodType == moodType));
}


@override
int get hashCode => Object.hash(runtimeType,moodType);

@override
String toString() {
  return 'MoodDiaryEvent.selectMood(moodType: $moodType)';
}


}

/// @nodoc
abstract mixin class _$SelectMoodCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$SelectMoodCopyWith(_SelectMood value, $Res Function(_SelectMood) _then) = __$SelectMoodCopyWithImpl;
@useResult
$Res call({
 MoodType moodType
});




}
/// @nodoc
class __$SelectMoodCopyWithImpl<$Res>
    implements _$SelectMoodCopyWith<$Res> {
  __$SelectMoodCopyWithImpl(this._self, this._then);

  final _SelectMood _self;
  final $Res Function(_SelectMood) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? moodType = null,}) {
  return _then(_SelectMood(
null == moodType ? _self.moodType : moodType // ignore: cast_nullable_to_non_nullable
as MoodType,
  ));
}


}

/// @nodoc


class _ToggleSubEmotion implements MoodDiaryEvent {
  const _ToggleSubEmotion(this.emotion);
  

 final  String emotion;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ToggleSubEmotionCopyWith<_ToggleSubEmotion> get copyWith => __$ToggleSubEmotionCopyWithImpl<_ToggleSubEmotion>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ToggleSubEmotion&&(identical(other.emotion, emotion) || other.emotion == emotion));
}


@override
int get hashCode => Object.hash(runtimeType,emotion);

@override
String toString() {
  return 'MoodDiaryEvent.toggleSubEmotion(emotion: $emotion)';
}


}

/// @nodoc
abstract mixin class _$ToggleSubEmotionCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$ToggleSubEmotionCopyWith(_ToggleSubEmotion value, $Res Function(_ToggleSubEmotion) _then) = __$ToggleSubEmotionCopyWithImpl;
@useResult
$Res call({
 String emotion
});




}
/// @nodoc
class __$ToggleSubEmotionCopyWithImpl<$Res>
    implements _$ToggleSubEmotionCopyWith<$Res> {
  __$ToggleSubEmotionCopyWithImpl(this._self, this._then);

  final _ToggleSubEmotion _self;
  final $Res Function(_ToggleSubEmotion) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? emotion = null,}) {
  return _then(_ToggleSubEmotion(
null == emotion ? _self.emotion : emotion // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _UpdateStressLevel implements MoodDiaryEvent {
  const _UpdateStressLevel(this.level);
  

 final  int level;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UpdateStressLevelCopyWith<_UpdateStressLevel> get copyWith => __$UpdateStressLevelCopyWithImpl<_UpdateStressLevel>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UpdateStressLevel&&(identical(other.level, level) || other.level == level));
}


@override
int get hashCode => Object.hash(runtimeType,level);

@override
String toString() {
  return 'MoodDiaryEvent.updateStressLevel(level: $level)';
}


}

/// @nodoc
abstract mixin class _$UpdateStressLevelCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$UpdateStressLevelCopyWith(_UpdateStressLevel value, $Res Function(_UpdateStressLevel) _then) = __$UpdateStressLevelCopyWithImpl;
@useResult
$Res call({
 int level
});




}
/// @nodoc
class __$UpdateStressLevelCopyWithImpl<$Res>
    implements _$UpdateStressLevelCopyWith<$Res> {
  __$UpdateStressLevelCopyWithImpl(this._self, this._then);

  final _UpdateStressLevel _self;
  final $Res Function(_UpdateStressLevel) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? level = null,}) {
  return _then(_UpdateStressLevel(
null == level ? _self.level : level // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _UpdateSelfEsteem implements MoodDiaryEvent {
  const _UpdateSelfEsteem(this.level);
  

 final  int level;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UpdateSelfEsteemCopyWith<_UpdateSelfEsteem> get copyWith => __$UpdateSelfEsteemCopyWithImpl<_UpdateSelfEsteem>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UpdateSelfEsteem&&(identical(other.level, level) || other.level == level));
}


@override
int get hashCode => Object.hash(runtimeType,level);

@override
String toString() {
  return 'MoodDiaryEvent.updateSelfEsteem(level: $level)';
}


}

/// @nodoc
abstract mixin class _$UpdateSelfEsteemCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$UpdateSelfEsteemCopyWith(_UpdateSelfEsteem value, $Res Function(_UpdateSelfEsteem) _then) = __$UpdateSelfEsteemCopyWithImpl;
@useResult
$Res call({
 int level
});




}
/// @nodoc
class __$UpdateSelfEsteemCopyWithImpl<$Res>
    implements _$UpdateSelfEsteemCopyWith<$Res> {
  __$UpdateSelfEsteemCopyWithImpl(this._self, this._then);

  final _UpdateSelfEsteem _self;
  final $Res Function(_UpdateSelfEsteem) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? level = null,}) {
  return _then(_UpdateSelfEsteem(
null == level ? _self.level : level // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _UpdateNote implements MoodDiaryEvent {
  const _UpdateNote(this.note);
  

 final  String note;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UpdateNoteCopyWith<_UpdateNote> get copyWith => __$UpdateNoteCopyWithImpl<_UpdateNote>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UpdateNote&&(identical(other.note, note) || other.note == note));
}


@override
int get hashCode => Object.hash(runtimeType,note);

@override
String toString() {
  return 'MoodDiaryEvent.updateNote(note: $note)';
}


}

/// @nodoc
abstract mixin class _$UpdateNoteCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$UpdateNoteCopyWith(_UpdateNote value, $Res Function(_UpdateNote) _then) = __$UpdateNoteCopyWithImpl;
@useResult
$Res call({
 String note
});




}
/// @nodoc
class __$UpdateNoteCopyWithImpl<$Res>
    implements _$UpdateNoteCopyWith<$Res> {
  __$UpdateNoteCopyWithImpl(this._self, this._then);

  final _UpdateNote _self;
  final $Res Function(_UpdateNote) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? note = null,}) {
  return _then(_UpdateNote(
null == note ? _self.note : note // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _UpdateDateTime implements MoodDiaryEvent {
  const _UpdateDateTime(this.dateTime);
  

 final  DateTime dateTime;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UpdateDateTimeCopyWith<_UpdateDateTime> get copyWith => __$UpdateDateTimeCopyWithImpl<_UpdateDateTime>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UpdateDateTime&&(identical(other.dateTime, dateTime) || other.dateTime == dateTime));
}


@override
int get hashCode => Object.hash(runtimeType,dateTime);

@override
String toString() {
  return 'MoodDiaryEvent.updateDateTime(dateTime: $dateTime)';
}


}

/// @nodoc
abstract mixin class _$UpdateDateTimeCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$UpdateDateTimeCopyWith(_UpdateDateTime value, $Res Function(_UpdateDateTime) _then) = __$UpdateDateTimeCopyWithImpl;
@useResult
$Res call({
 DateTime dateTime
});




}
/// @nodoc
class __$UpdateDateTimeCopyWithImpl<$Res>
    implements _$UpdateDateTimeCopyWith<$Res> {
  __$UpdateDateTimeCopyWithImpl(this._self, this._then);

  final _UpdateDateTime _self;
  final $Res Function(_UpdateDateTime) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? dateTime = null,}) {
  return _then(_UpdateDateTime(
null == dateTime ? _self.dateTime : dateTime // ignore: cast_nullable_to_non_nullable
as DateTime,
  ));
}


}

/// @nodoc


class _SaveEntry implements MoodDiaryEvent {
  const _SaveEntry();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SaveEntry);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent.saveEntry()';
}


}




/// @nodoc


class _ResetForm implements MoodDiaryEvent {
  const _ResetForm();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ResetForm);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent.resetForm()';
}


}




/// @nodoc


class _SwitchTab implements MoodDiaryEvent {
  const _SwitchTab(this.tabIndex);
  

 final  int tabIndex;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SwitchTabCopyWith<_SwitchTab> get copyWith => __$SwitchTabCopyWithImpl<_SwitchTab>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SwitchTab&&(identical(other.tabIndex, tabIndex) || other.tabIndex == tabIndex));
}


@override
int get hashCode => Object.hash(runtimeType,tabIndex);

@override
String toString() {
  return 'MoodDiaryEvent.switchTab(tabIndex: $tabIndex)';
}


}

/// @nodoc
abstract mixin class _$SwitchTabCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$SwitchTabCopyWith(_SwitchTab value, $Res Function(_SwitchTab) _then) = __$SwitchTabCopyWithImpl;
@useResult
$Res call({
 int tabIndex
});




}
/// @nodoc
class __$SwitchTabCopyWithImpl<$Res>
    implements _$SwitchTabCopyWith<$Res> {
  __$SwitchTabCopyWithImpl(this._self, this._then);

  final _SwitchTab _self;
  final $Res Function(_SwitchTab) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tabIndex = null,}) {
  return _then(_SwitchTab(
null == tabIndex ? _self.tabIndex : tabIndex // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _DeleteEntry implements MoodDiaryEvent {
  const _DeleteEntry(this.id);
  

 final  String id;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteEntryCopyWith<_DeleteEntry> get copyWith => __$DeleteEntryCopyWithImpl<_DeleteEntry>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteEntry&&(identical(other.id, id) || other.id == id));
}


@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'MoodDiaryEvent.deleteEntry(id: $id)';
}


}

/// @nodoc
abstract mixin class _$DeleteEntryCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$DeleteEntryCopyWith(_DeleteEntry value, $Res Function(_DeleteEntry) _then) = __$DeleteEntryCopyWithImpl;
@useResult
$Res call({
 String id
});




}
/// @nodoc
class __$DeleteEntryCopyWithImpl<$Res>
    implements _$DeleteEntryCopyWith<$Res> {
  __$DeleteEntryCopyWithImpl(this._self, this._then);

  final _DeleteEntry _self;
  final $Res Function(_DeleteEntry) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? id = null,}) {
  return _then(_DeleteEntry(
null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _StartEditEntry implements MoodDiaryEvent {
  const _StartEditEntry(this.entry);
  

 final  MoodEntry entry;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StartEditEntryCopyWith<_StartEditEntry> get copyWith => __$StartEditEntryCopyWithImpl<_StartEditEntry>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StartEditEntry&&(identical(other.entry, entry) || other.entry == entry));
}


@override
int get hashCode => Object.hash(runtimeType,entry);

@override
String toString() {
  return 'MoodDiaryEvent.startEditEntry(entry: $entry)';
}


}

/// @nodoc
abstract mixin class _$StartEditEntryCopyWith<$Res> implements $MoodDiaryEventCopyWith<$Res> {
  factory _$StartEditEntryCopyWith(_StartEditEntry value, $Res Function(_StartEditEntry) _then) = __$StartEditEntryCopyWithImpl;
@useResult
$Res call({
 MoodEntry entry
});


$MoodEntryCopyWith<$Res> get entry;

}
/// @nodoc
class __$StartEditEntryCopyWithImpl<$Res>
    implements _$StartEditEntryCopyWith<$Res> {
  __$StartEditEntryCopyWithImpl(this._self, this._then);

  final _StartEditEntry _self;
  final $Res Function(_StartEditEntry) _then;

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? entry = null,}) {
  return _then(_StartEditEntry(
null == entry ? _self.entry : entry // ignore: cast_nullable_to_non_nullable
as MoodEntry,
  ));
}

/// Create a copy of MoodDiaryEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MoodEntryCopyWith<$Res> get entry {
  
  return $MoodEntryCopyWith<$Res>(_self.entry, (value) {
    return _then(_self.copyWith(entry: value));
  });
}
}

/// @nodoc


class _UpdateEntry implements MoodDiaryEvent {
  const _UpdateEntry();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UpdateEntry);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent.updateEntry()';
}


}




/// @nodoc


class _CancelEdit implements MoodDiaryEvent {
  const _CancelEdit();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CancelEdit);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MoodDiaryEvent.cancelEdit()';
}


}




/// @nodoc
mixin _$MoodDiaryState {

 List<MoodEntry> get entries; MoodType? get selectedMood; List<String> get selectedSubEmotions; int get stressLevel; int get selfEsteem; String get note; DateTime? get selectedDateTime; bool get isLoading; bool get isSaving; bool get isSaved; String? get errorMessage; int get currentTabIndex; String? get editingEntryId; bool get isEditing;
/// Create a copy of MoodDiaryState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MoodDiaryStateCopyWith<MoodDiaryState> get copyWith => _$MoodDiaryStateCopyWithImpl<MoodDiaryState>(this as MoodDiaryState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MoodDiaryState&&const DeepCollectionEquality().equals(other.entries, entries)&&(identical(other.selectedMood, selectedMood) || other.selectedMood == selectedMood)&&const DeepCollectionEquality().equals(other.selectedSubEmotions, selectedSubEmotions)&&(identical(other.stressLevel, stressLevel) || other.stressLevel == stressLevel)&&(identical(other.selfEsteem, selfEsteem) || other.selfEsteem == selfEsteem)&&(identical(other.note, note) || other.note == note)&&(identical(other.selectedDateTime, selectedDateTime) || other.selectedDateTime == selectedDateTime)&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&(identical(other.isSaving, isSaving) || other.isSaving == isSaving)&&(identical(other.isSaved, isSaved) || other.isSaved == isSaved)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.currentTabIndex, currentTabIndex) || other.currentTabIndex == currentTabIndex)&&(identical(other.editingEntryId, editingEntryId) || other.editingEntryId == editingEntryId)&&(identical(other.isEditing, isEditing) || other.isEditing == isEditing));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(entries),selectedMood,const DeepCollectionEquality().hash(selectedSubEmotions),stressLevel,selfEsteem,note,selectedDateTime,isLoading,isSaving,isSaved,errorMessage,currentTabIndex,editingEntryId,isEditing);

@override
String toString() {
  return 'MoodDiaryState(entries: $entries, selectedMood: $selectedMood, selectedSubEmotions: $selectedSubEmotions, stressLevel: $stressLevel, selfEsteem: $selfEsteem, note: $note, selectedDateTime: $selectedDateTime, isLoading: $isLoading, isSaving: $isSaving, isSaved: $isSaved, errorMessage: $errorMessage, currentTabIndex: $currentTabIndex, editingEntryId: $editingEntryId, isEditing: $isEditing)';
}


}

/// @nodoc
abstract mixin class $MoodDiaryStateCopyWith<$Res>  {
  factory $MoodDiaryStateCopyWith(MoodDiaryState value, $Res Function(MoodDiaryState) _then) = _$MoodDiaryStateCopyWithImpl;
@useResult
$Res call({
 List<MoodEntry> entries, MoodType? selectedMood, List<String> selectedSubEmotions, int stressLevel, int selfEsteem, String note, DateTime? selectedDateTime, bool isLoading, bool isSaving, bool isSaved, String? errorMessage, int currentTabIndex, String? editingEntryId, bool isEditing
});




}
/// @nodoc
class _$MoodDiaryStateCopyWithImpl<$Res>
    implements $MoodDiaryStateCopyWith<$Res> {
  _$MoodDiaryStateCopyWithImpl(this._self, this._then);

  final MoodDiaryState _self;
  final $Res Function(MoodDiaryState) _then;

/// Create a copy of MoodDiaryState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? entries = null,Object? selectedMood = freezed,Object? selectedSubEmotions = null,Object? stressLevel = null,Object? selfEsteem = null,Object? note = null,Object? selectedDateTime = freezed,Object? isLoading = null,Object? isSaving = null,Object? isSaved = null,Object? errorMessage = freezed,Object? currentTabIndex = null,Object? editingEntryId = freezed,Object? isEditing = null,}) {
  return _then(_self.copyWith(
entries: null == entries ? _self.entries : entries // ignore: cast_nullable_to_non_nullable
as List<MoodEntry>,selectedMood: freezed == selectedMood ? _self.selectedMood : selectedMood // ignore: cast_nullable_to_non_nullable
as MoodType?,selectedSubEmotions: null == selectedSubEmotions ? _self.selectedSubEmotions : selectedSubEmotions // ignore: cast_nullable_to_non_nullable
as List<String>,stressLevel: null == stressLevel ? _self.stressLevel : stressLevel // ignore: cast_nullable_to_non_nullable
as int,selfEsteem: null == selfEsteem ? _self.selfEsteem : selfEsteem // ignore: cast_nullable_to_non_nullable
as int,note: null == note ? _self.note : note // ignore: cast_nullable_to_non_nullable
as String,selectedDateTime: freezed == selectedDateTime ? _self.selectedDateTime : selectedDateTime // ignore: cast_nullable_to_non_nullable
as DateTime?,isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,isSaving: null == isSaving ? _self.isSaving : isSaving // ignore: cast_nullable_to_non_nullable
as bool,isSaved: null == isSaved ? _self.isSaved : isSaved // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,currentTabIndex: null == currentTabIndex ? _self.currentTabIndex : currentTabIndex // ignore: cast_nullable_to_non_nullable
as int,editingEntryId: freezed == editingEntryId ? _self.editingEntryId : editingEntryId // ignore: cast_nullable_to_non_nullable
as String?,isEditing: null == isEditing ? _self.isEditing : isEditing // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [MoodDiaryState].
extension MoodDiaryStatePatterns on MoodDiaryState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _MoodDiaryState value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _MoodDiaryState() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _MoodDiaryState value)  $default,){
final _that = this;
switch (_that) {
case _MoodDiaryState():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _MoodDiaryState value)?  $default,){
final _that = this;
switch (_that) {
case _MoodDiaryState() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( List<MoodEntry> entries,  MoodType? selectedMood,  List<String> selectedSubEmotions,  int stressLevel,  int selfEsteem,  String note,  DateTime? selectedDateTime,  bool isLoading,  bool isSaving,  bool isSaved,  String? errorMessage,  int currentTabIndex,  String? editingEntryId,  bool isEditing)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _MoodDiaryState() when $default != null:
return $default(_that.entries,_that.selectedMood,_that.selectedSubEmotions,_that.stressLevel,_that.selfEsteem,_that.note,_that.selectedDateTime,_that.isLoading,_that.isSaving,_that.isSaved,_that.errorMessage,_that.currentTabIndex,_that.editingEntryId,_that.isEditing);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( List<MoodEntry> entries,  MoodType? selectedMood,  List<String> selectedSubEmotions,  int stressLevel,  int selfEsteem,  String note,  DateTime? selectedDateTime,  bool isLoading,  bool isSaving,  bool isSaved,  String? errorMessage,  int currentTabIndex,  String? editingEntryId,  bool isEditing)  $default,) {final _that = this;
switch (_that) {
case _MoodDiaryState():
return $default(_that.entries,_that.selectedMood,_that.selectedSubEmotions,_that.stressLevel,_that.selfEsteem,_that.note,_that.selectedDateTime,_that.isLoading,_that.isSaving,_that.isSaved,_that.errorMessage,_that.currentTabIndex,_that.editingEntryId,_that.isEditing);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( List<MoodEntry> entries,  MoodType? selectedMood,  List<String> selectedSubEmotions,  int stressLevel,  int selfEsteem,  String note,  DateTime? selectedDateTime,  bool isLoading,  bool isSaving,  bool isSaved,  String? errorMessage,  int currentTabIndex,  String? editingEntryId,  bool isEditing)?  $default,) {final _that = this;
switch (_that) {
case _MoodDiaryState() when $default != null:
return $default(_that.entries,_that.selectedMood,_that.selectedSubEmotions,_that.stressLevel,_that.selfEsteem,_that.note,_that.selectedDateTime,_that.isLoading,_that.isSaving,_that.isSaved,_that.errorMessage,_that.currentTabIndex,_that.editingEntryId,_that.isEditing);case _:
  return null;

}
}

}

/// @nodoc


class _MoodDiaryState implements MoodDiaryState {
  const _MoodDiaryState({final  List<MoodEntry> entries = const [], this.selectedMood, final  List<String> selectedSubEmotions = const [], this.stressLevel = 50, this.selfEsteem = 50, this.note = '', this.selectedDateTime, this.isLoading = false, this.isSaving = false, this.isSaved = false, this.errorMessage, this.currentTabIndex = 0, this.editingEntryId, this.isEditing = false}): _entries = entries,_selectedSubEmotions = selectedSubEmotions;
  

 final  List<MoodEntry> _entries;
@override@JsonKey() List<MoodEntry> get entries {
  if (_entries is EqualUnmodifiableListView) return _entries;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_entries);
}

@override final  MoodType? selectedMood;
 final  List<String> _selectedSubEmotions;
@override@JsonKey() List<String> get selectedSubEmotions {
  if (_selectedSubEmotions is EqualUnmodifiableListView) return _selectedSubEmotions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_selectedSubEmotions);
}

@override@JsonKey() final  int stressLevel;
@override@JsonKey() final  int selfEsteem;
@override@JsonKey() final  String note;
@override final  DateTime? selectedDateTime;
@override@JsonKey() final  bool isLoading;
@override@JsonKey() final  bool isSaving;
@override@JsonKey() final  bool isSaved;
@override final  String? errorMessage;
@override@JsonKey() final  int currentTabIndex;
@override final  String? editingEntryId;
@override@JsonKey() final  bool isEditing;

/// Create a copy of MoodDiaryState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MoodDiaryStateCopyWith<_MoodDiaryState> get copyWith => __$MoodDiaryStateCopyWithImpl<_MoodDiaryState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MoodDiaryState&&const DeepCollectionEquality().equals(other._entries, _entries)&&(identical(other.selectedMood, selectedMood) || other.selectedMood == selectedMood)&&const DeepCollectionEquality().equals(other._selectedSubEmotions, _selectedSubEmotions)&&(identical(other.stressLevel, stressLevel) || other.stressLevel == stressLevel)&&(identical(other.selfEsteem, selfEsteem) || other.selfEsteem == selfEsteem)&&(identical(other.note, note) || other.note == note)&&(identical(other.selectedDateTime, selectedDateTime) || other.selectedDateTime == selectedDateTime)&&(identical(other.isLoading, isLoading) || other.isLoading == isLoading)&&(identical(other.isSaving, isSaving) || other.isSaving == isSaving)&&(identical(other.isSaved, isSaved) || other.isSaved == isSaved)&&(identical(other.errorMessage, errorMessage) || other.errorMessage == errorMessage)&&(identical(other.currentTabIndex, currentTabIndex) || other.currentTabIndex == currentTabIndex)&&(identical(other.editingEntryId, editingEntryId) || other.editingEntryId == editingEntryId)&&(identical(other.isEditing, isEditing) || other.isEditing == isEditing));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_entries),selectedMood,const DeepCollectionEquality().hash(_selectedSubEmotions),stressLevel,selfEsteem,note,selectedDateTime,isLoading,isSaving,isSaved,errorMessage,currentTabIndex,editingEntryId,isEditing);

@override
String toString() {
  return 'MoodDiaryState(entries: $entries, selectedMood: $selectedMood, selectedSubEmotions: $selectedSubEmotions, stressLevel: $stressLevel, selfEsteem: $selfEsteem, note: $note, selectedDateTime: $selectedDateTime, isLoading: $isLoading, isSaving: $isSaving, isSaved: $isSaved, errorMessage: $errorMessage, currentTabIndex: $currentTabIndex, editingEntryId: $editingEntryId, isEditing: $isEditing)';
}


}

/// @nodoc
abstract mixin class _$MoodDiaryStateCopyWith<$Res> implements $MoodDiaryStateCopyWith<$Res> {
  factory _$MoodDiaryStateCopyWith(_MoodDiaryState value, $Res Function(_MoodDiaryState) _then) = __$MoodDiaryStateCopyWithImpl;
@override @useResult
$Res call({
 List<MoodEntry> entries, MoodType? selectedMood, List<String> selectedSubEmotions, int stressLevel, int selfEsteem, String note, DateTime? selectedDateTime, bool isLoading, bool isSaving, bool isSaved, String? errorMessage, int currentTabIndex, String? editingEntryId, bool isEditing
});




}
/// @nodoc
class __$MoodDiaryStateCopyWithImpl<$Res>
    implements _$MoodDiaryStateCopyWith<$Res> {
  __$MoodDiaryStateCopyWithImpl(this._self, this._then);

  final _MoodDiaryState _self;
  final $Res Function(_MoodDiaryState) _then;

/// Create a copy of MoodDiaryState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? entries = null,Object? selectedMood = freezed,Object? selectedSubEmotions = null,Object? stressLevel = null,Object? selfEsteem = null,Object? note = null,Object? selectedDateTime = freezed,Object? isLoading = null,Object? isSaving = null,Object? isSaved = null,Object? errorMessage = freezed,Object? currentTabIndex = null,Object? editingEntryId = freezed,Object? isEditing = null,}) {
  return _then(_MoodDiaryState(
entries: null == entries ? _self._entries : entries // ignore: cast_nullable_to_non_nullable
as List<MoodEntry>,selectedMood: freezed == selectedMood ? _self.selectedMood : selectedMood // ignore: cast_nullable_to_non_nullable
as MoodType?,selectedSubEmotions: null == selectedSubEmotions ? _self._selectedSubEmotions : selectedSubEmotions // ignore: cast_nullable_to_non_nullable
as List<String>,stressLevel: null == stressLevel ? _self.stressLevel : stressLevel // ignore: cast_nullable_to_non_nullable
as int,selfEsteem: null == selfEsteem ? _self.selfEsteem : selfEsteem // ignore: cast_nullable_to_non_nullable
as int,note: null == note ? _self.note : note // ignore: cast_nullable_to_non_nullable
as String,selectedDateTime: freezed == selectedDateTime ? _self.selectedDateTime : selectedDateTime // ignore: cast_nullable_to_non_nullable
as DateTime?,isLoading: null == isLoading ? _self.isLoading : isLoading // ignore: cast_nullable_to_non_nullable
as bool,isSaving: null == isSaving ? _self.isSaving : isSaving // ignore: cast_nullable_to_non_nullable
as bool,isSaved: null == isSaved ? _self.isSaved : isSaved // ignore: cast_nullable_to_non_nullable
as bool,errorMessage: freezed == errorMessage ? _self.errorMessage : errorMessage // ignore: cast_nullable_to_non_nullable
as String?,currentTabIndex: null == currentTabIndex ? _self.currentTabIndex : currentTabIndex // ignore: cast_nullable_to_non_nullable
as int,editingEntryId: freezed == editingEntryId ? _self.editingEntryId : editingEntryId // ignore: cast_nullable_to_non_nullable
as String?,isEditing: null == isEditing ? _self.isEditing : isEditing // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on
